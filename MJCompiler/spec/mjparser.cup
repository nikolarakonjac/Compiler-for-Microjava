package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	errorDetected = true;
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


init with {:
	errorDetected = false;
:}



/* ------------------------ TERMINALS ----------------------------- */

terminal PROGRAM, IDENT, LBRACE, RBRACE, CONST, SEMICOLON, NUMBER, CHAR, BOOL, COMMA, LBRACKET, RBRACKET, ASSIGN, VOID, MINUS, INC, DEC, OR, AND;
terminal IF, ELSE, NEW, BREAK, CONTINUE, RETURN, PLUS, RPAREN, STATIC, DIV, NOT_EQUAL, ARROW, LPAREN, EQUAL, LESS, MOD, MUL, GREATER, GREATER_EQUAL, LESS_EQUAL;
terminal READ, PRINT, COLON;

/* terminals needed because of Yylex.java*/

terminal FOR, EXTENDS, DOT;
terminal RANGE, NAMESPACE, CLASS;

/* ------------------------ NONTERMINALS ----------------------------- */

nonterminal Program, DeclarationList, MethodDeclList, ConstDecl, VarDecl, ConstAssign, ConstAssignList, Type;
nonterminal VarDeclaration, VarDeclarations, MethodDecl, VarDeclList, StatementList, FormPars, FormalParam, FormalParams;
nonterminal MethodReturnTypeAndName, Statement, DesignatorStatement, Designator,  Expr, Label, Term, Factor, DesignatorFactor, NewFactor, ExprFactor;
nonterminal ActParsOptional, ActPars, StaticInitializer, CondFact, Condition, CondTerm, FinalVarDeclaration;
nonterminal Relop, Assignop, Addop, Mulop; 


/* can be used only for this case*/
precedence left ELSE;

/* ------------------------ GRAMMAR ----------------------------- */

Program ::= (Program) PROGRAM IDENT:programName DeclarationList LBRACE MethodDeclList RBRACE;

DeclarationList ::= (DeclarationListConst) DeclarationList ConstDecl
                |
                (DeclarationListVar) DeclarationList VarDecl
                |
                (NoDeclarationList) /* epsilon */
                ;
                
ConstDecl ::= (ConstDeclaration) CONST Type:constType IDENT:constIdent ASSIGN ConstAssign ConstAssignList SEMICOLON;

ConstAssign ::= (NumberConstValue) NUMBER
			|
			(CharConstValue) CHAR
			|
			(BoolConstValue) BOOL
			;

ConstAssignList ::= (ConstAssignmentList) ConstAssignList COMMA IDENT ASSIGN ConstAssign
				|
				(NoConstAssignmentList) /* epsilon */
				;

VarDecl ::= (VarDecl) Type VarDeclarations;

VarDeclarations ::= (VarDeclarationList) VarDeclaration VarDeclarations
				|
				(SingleVarDeclaration) FinalVarDeclaration
				;

		
FinalVarDeclaration ::= IDENT SEMICOLON
					|
					IDENT LBRACKET RBRACKET SEMICOLON
					|
					error SEMICOLON:l
					{: parser.report_error("oporavak od greske za definiciju globalne promenljive do znaka ; na liniji: " + lleft, null); :}
					;
					

VarDeclaration ::= (VarDeclaration) IDENT COMMA
				| 
				(ArrayVarDeclaration) IDENT LBRACKET RBRACKET COMMA
				|
				error COMMA:l 
				{: parser.report_error("oporavak od greske za definiciju globalne promenljive do znaka , na liniji: " + lleft, null); :}
				;


				
Type ::= (ScopeResolution) IDENT COLON COLON IDENT
       |
       (TypeName) IDENT
       ;		
				
MethodDeclList ::= MethodDeclList MethodDecl
				|
				/* epsilon */	
				;

VarDeclList ::= VarDeclList VarDecl
			|
			/* epsilon */
			;
				
MethodDecl ::= MethodReturnTypeAndName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList  RBRACE;		
				
MethodReturnTypeAndName ::= VOID IDENT
						|
						Type IDENT
						;
								
FormPars ::= (FormParsExist) FormalParams
			|
			(NoFormalParams) /* epsilon */
			;			
				
FormalParams ::= (FormalParamsList) FormalParams COMMA FormalParam
				|
				(SingleFormalParam) FormalParam
				;  			
				
FormalParam ::= (VariableFormalParam) Type IDENT
			|
			(ArrayFormalParam) Type IDENT LBRACKET RBRACKET
			; 			

/*	****************************************		*/
				
StatementList ::= StatementList Statement
				|
				/* epsilon */		
				;		

Statement ::= DesignatorStatement
			|
			IF LPAREN Condition RPAREN Statement
			|
			IF LPAREN Condition RPAREN Statement ELSE Statement
			|
			BREAK SEMICOLON
			|
			CONTINUE SEMICOLON
			|
			RETURN SEMICOLON
			|
			RETURN Expr SEMICOLON
			|
			READ LPAREN Designator RPAREN SEMICOLON
			|
			PRINT LPAREN Expr RPAREN SEMICOLON
			|
			PRINT LPAREN Expr COMMA NUMBER RPAREN SEMICOLON
			|
			LBRACE StatementList RBRACE
			;


DesignatorStatement ::= Designator Assignop Expr SEMICOLON
					|
					Designator LPAREN ActParsOptional RPAREN SEMICOLON
					|
					Designator INC SEMICOLON
					|
					Designator DEC SEMICOLON
					|
					error SEMICOLON:l 
					{: parser.report_error("oporavak od greske za iskaz dodele do znaka ; na liniji: " + lleft, null); :}
					;

Designator ::= IDENT COLON COLON IDENT
			|
			IDENT 
			|
			Designator DOT IDENT
			|
			Designator LBRACKET Expr RBRACKET
			;

Expr ::= MINUS Term
        |
        Term
        |
        Expr Addop Term
        ;
        
Term ::= Factor
		|
		Term Mulop Factor
		;
		
Factor ::= NUMBER
		|
		CHAR
		|
		BOOL
		|
		DesignatorFactor
		|
		NewFactor
		|
		ExprFactor
		;
		
DesignatorFactor ::= Designator
					|
					Designator LPAREN ActParsOptional RPAREN
					;
					
NewFactor ::= NEW Type LBRACKET Expr RBRACKET
			|
			NEW Type LPAREN ActParsOptional RPAREN
			;
			
ExprFactor ::= LPAREN Expr RPAREN;


ActParsOptional ::= ActPars
		|
		/* epsilon */
		;

ActPars ::= Expr
		|
		ActPars COMMA Expr
		;	
		
StaticInitializer ::= STATIC LBRACE StatementList RBRACE;
		
/* *********************************************** */	

Condition ::= CondTerm 
			|
			Condition OR CondTerm
			;

CondTerm ::= CondFact 
			|
			CondTerm AND CondFact
			;

CondFact ::= Expr Relop Expr
			|
			Expr
			;
			

/* *********************************************** */

Label ::= IDENT;

Assignop ::= ASSIGN;
				
Relop ::= EQUAL
        |
        NOT_EQUAL
        |
        GREATER
        |
        GREATER_EQUAL
        |
        LESS
        |
        LESS_EQUAL
        ;			
				
Addop ::= PLUS
        |
        MINUS	
        ;			
				
Mulop ::= MUL
        |
        DIV
        |
        MOD
        ;				
				
				
				

				
				
				
				
				
				
				
				
				
				
				
				
				
				
				